{"version":3,"file":"workbox-window.dev.umd.js","sources":["../_version.mjs","../messageSW.mjs","../../workbox-core/_version.mjs","../../workbox-core/_private/Deferred.mjs","../../workbox-core/_private/logger.mjs","../utils/EventTargetShim.mjs","../utils/urlsMatch.mjs","../utils/WorkboxEvent.mjs","../Workbox.mjs","../index.mjs"],"sourcesContent":["try{self['workbox:window:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n *\n * @memberof module:workbox-window\n */\nconst messageSW = (sw, data) => {\n  return new Promise((resolve) => {\n    let messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = (evt) => resolve(evt.data);\n    sw.postMessage(data, [messageChannel.port2]);\n  });\n};\n\nexport {messageSW};\n","try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nexport class Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\n  let inGroup = false;\n\n  const methodToColorMap = {\n    debug: `#7f8c8d`, // Gray\n    log: `#2ecc71`, // Green\n    warn: `#f39c12`, // Yellow\n    error: `#c0392b`, // Red\n    groupCollapsed: `#3498db`, // Blue\n    groupEnd: null, // No colored prefix on groupEnd\n  };\n\n  const print = function(method, args) {\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        console[method](...args);\n        return;\n      }\n    }\n\n    const styles = [\n      `background: ${methodToColorMap[method]}`,\n      `border-radius: 0.5em`,\n      `color: white`,\n      `font-weight: bold`,\n      `padding: 2px 0.5em`,\n    ];\n\n    // When in a group, the workbox prefix is not displayed.\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    console[method](...logPrefix, ...args);\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  const api = {};\n  for (const method of Object.keys(methodToColorMap)) {\n    api[method] = (...args) => {\n      print(method, args);\n    };\n  }\n\n  return api;\n})();\n\nexport {logger};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nclass EventTargetShim {\n  /**\n   * Creates an event listener registry\n   *\n   * @private\n   */\n  constructor() {\n    // A registry of event types to listeners.\n    this._eventListenerRegistry = {};\n  }\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  addEventListener(type, listener) {\n    this._getEventListenersByType(type).add(listener);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  removeEventListener(type, listener) {\n    this._getEventListenersByType(type).delete(listener);\n  }\n\n  /**\n   * @param {Event} event\n   * @private\n   */\n  dispatchEvent(event) {\n    event.target = this;\n    this._getEventListenersByType(event.type).forEach(\n        (listener) => listener(event));\n  }\n\n  /**\n   * Returns a Set of listeners associated with the passed event type.\n   * If no handlers have been registered, an empty Set is returned.\n   *\n   * @param {string} type The event type.\n   * @return {Set} An array of handler functions.\n   * @private\n   */\n  _getEventListenersByType(type) {\n    return this._eventListenerRegistry[type] =\n        (this._eventListenerRegistry[type] || new Set());\n  }\n}\n\nexport {EventTargetShim};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nconst urlsMatch = (url1, url2) => {\n  return new URL(url1, location).href === new URL(url2, location).href;\n};\n\nexport {urlsMatch};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nclass WorkboxEvent {\n  /**\n   * @param {string} type\n   * @param {Object} props\n   */\n  constructor(type, props) {\n    Object.assign(this, props, {type});\n  }\n}\n\nexport {WorkboxEvent};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {messageSW} from './messageSW.mjs';\nimport {EventTargetShim} from './utils/EventTargetShim.mjs';\nimport {urlsMatch} from './utils/urlsMatch.mjs';\nimport {WorkboxEvent} from './utils/WorkboxEvent.mjs';\nimport './_version.mjs';\n\n\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n *\n * @memberof module:workbox-window\n */\nclass Workbox extends EventTargetShim {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions;\n    this._updateFoundCount = 0;\n\n    // Deferreds we can resolve later.\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred();\n\n    // Bind event handler callbacks.\n    this._onMessage = this._onMessage.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._onUpdateFound = this._onUpdateFound.bind(this);\n    this._onControllerChange = this._onControllerChange.bind(this);\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n  async register({immediate = false} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' +\n            'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise((res) => addEventListener('load', res));\n    }\n\n    // Set this flag to true if any service worker was controlling the page\n    // at registration time.\n    this._isUpdate = Boolean(navigator.serviceWorker.controller);\n\n    // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n\n    this._registration = await this._registerScript();\n\n    // If we have a compatible controller, store the controller as the \"own\"\n    // SW, resolve active/controlling deferreds and add necessary listeners.\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._reportWindowReady(this._compatibleControllingSW);\n      this._compatibleControllingSW.addEventListener(\n          'statechange', this._onStateChange, {once: true});\n    }\n\n    // If there's a waiting service worker with a matching URL before the\n    // `updatefound` event fires, it likely means that this site is open\n    // in another tab, or the user refreshed the page (and thus the prevoius\n    // page wasn't fully unloaded before this page started loading).\n    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n    const waitingSW = this._registration.waiting;\n    if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n      // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n      // a compatible controller.\n      this._sw = waitingSW;\n\n      // Run this in the next microtask, so any code that adds an event\n      // listener after awaiting `register()` will get this event.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new WorkboxEvent('waiting', {\n          sw: waitingSW,\n          wasWaitingBeforeRegister: true,\n        }));\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('A service worker was already waiting to activate ' +\n              'before this script was registered...');\n        }\n      });\n    }\n\n    // If an \"own\" SW is already set, resolve the deferred.\n    if (this._sw) {\n      this._swDeferred.resolve(this._sw);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' +\n              'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' +\n              'currently controlling the page. The browser is now fetching ' +\n              'the new script now...');\n     