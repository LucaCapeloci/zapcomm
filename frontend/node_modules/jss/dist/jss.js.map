{"version":3,"file":"jss.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/extends.js","../../../node_modules/is-in-browser/dist/module.js","../../../node_modules/tiny-warning/dist/tiny-warning.esm.js","../src/utils/cloneStyle.js","../src/utils/createRule.js","../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../src/utils/toCssValue.js","../src/utils/getWhitespaceSymbols.js","../src/utils/toCss.js","../src/utils/escape.js","../src/plugins/styleRule.js","../src/plugins/conditionalRule.js","../src/plugins/keyframesRule.js","../src/plugins/keyframeRule.js","../src/plugins/fontFaceRule.js","../src/plugins/viewportRule.js","../src/plugins/simpleRule.js","../src/plugins/index.js","../src/RuleList.js","../src/StyleSheet.js","../src/PluginsRegistry.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../src/SheetsRegistry.js","../src/sheets.js","../src/utils/globalThis.js","../src/utils/moduleId.js","../src/utils/createGenerateId.js","../src/DomRenderer.js","../src/Jss.js","../src/utils/createJss.js","../src/SheetsManager.js","../src/utils/hasCSSTOMSupport.js","../src/utils/getDynamicStyles.js","../src/index.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexport var isBrowser = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && (typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) === 'object' && document.nodeType === 9;\n\nexport default isBrowser;\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","const plainObjectConstrurctor = {}.constructor\n\nexport default function cloneStyle(style) {\n  if (style == null || typeof style !== 'object') return style\n  if (Array.isArray(style)) return style.map(cloneStyle)\n  if (style.constructor !== plainObjectConstrurctor) return style\n\n  const newStyle = {}\n  for (const name in style) {\n    newStyle[name] = cloneStyle(style[name])\n  }\n  return newStyle\n}\n","import warning from 'tiny-warning'\nimport cloneStyle from './cloneStyle'\n\n/**\n * Create a rule instance.\n */\nexport default function createRule(name = 'unnamed', decl, options) {\n  const {jss} = options\n  const declCopy = cloneStyle(decl)\n\n  const rule = jss.plugins.onCreateRule(name, declCopy, options)\n  if (rule) return rule\n\n  // It is an at-rule and it has no instance.\n  if (name[0] === '@') {\n    warning(false, `[JSS] Unknown rule ${name}`)\n  }\n\n  return null\n}\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","const join = (value, by) => {\n  let result = ''\n  for (let i = 0; i < value.length; i++) {\n    // Remove !important from the value, it will be readded later.\n    if (value[i] === '!important') break\n    if (result) result += by\n    result += value[i]\n  }\n  return result\n}\n\n/**\n * Converts JSS array value to a CSS string.\n *\n * `margin: [['5px', '10px']]` > `margin: 5px 10px;`\n * `border: ['1px', '2px']` > `border: 1px, 2px;`\n * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`\n * `color: ['red', !important]` > `color: red !important;`\n */\nconst toCssValue = (value) => {\n  if (!Array.isArray(value)) return value\n\n  let cssValue = ''\n\n  // Support space separated values via `[['5px', '10px']]`.\n  if (Array.isArray(value[0])) {\n    for (let i = 0; i < value.length; i++) {\n      if (value[i] === '!important') break\n      if (cssValue) cssValue += ', '\n      cssValue += join(value[i], ' ')\n    }\n  } else cssValue = join(value, ', ')\n\n  // Add !important, because it was ignored.\n  if (value[value.length - 1] === '!important') {\n    cssValue += ' !important'\n  }\n\n  return cssValue\n}\n\nexport default toCssValue\n","export default function getWhitespaceSymbols(options) {\n  if (options && options.format === false) {\n    return {\n      linebreak: '',\n      space: ''\n    }\n  }\n\n  return {\n    linebreak: '\\n',\n    space: ' '\n  }\n}\n","import toCssValue from './toCssValue'\nimport getWhitespaceSymbols from './getWhitespaceSymbols'\n\n/**\n * Indent a string.\n * http://jsperf.com/array-join-vs-for\n */\nfunction indentStr(str, indent) {\n  let result = ''\n  for (let index = 0; index < indent; index++) result += '  '\n  return result + str\n}\n\n/**\n * Converts a Rule to CSS string.\n */\nexport default function toCss(selector, style, options = {}) {\n  let result = ''\n\n  if (!style) return result\n\n  let {indent = 0} = options\n  const {fallbacks} = style\n\n  if (options.format === false) {\n    indent = -Infinity\n  }\n  const {linebreak, space} = getWhitespaceSymbols(options)\n\n  if (selector) indent++\n\n  // Apply fallbacks first.\n  if (fallbacks) {\n    // Array syntax {fallbacks: [{prop: value}]}\n    if (Array.isArray(fallbacks)) {\n      for (let index = 0; index < fallbacks.length; index++) {\n        const fallback = fallbacks[index]\n        for (const prop in fallback) {\n          const value = fallback[prop]\n          if (value != null) {\n            if (result) result += linebreak\n            result += indentStr(`${prop}:${space}${toCssValue(value)};`, indent)\n          }\n        }\n      }\n    } else {\n      // Object syntax {fallbacks: {prop: value}}\n      for (const prop in fallbacks) {\n        const value = fallbacks[prop]\n        if (value != null) {\n          if (result) result += linebreak\n          result += indentStr(`${prop}:${space}${toCssValue(value)};`, indent)\n        }\n      }\n    }\n  }\n\n  for (const prop in style) {\n    const value = style[prop]\n    if (value != null && prop !== 'fallbacks') {\n      if (result) result += linebreak\n      result += indentStr(`${prop}:${space}${toCssValue(value)};`, indent)\n    }\n  }\n\n  // Allow empty style in this case, because properties will be added dynamically.\n  if (!result && !options.allowEmpty) return result\n\n  // When rule is being stringified before selector was defined.\n  if (!selector) return result\n\n  indent--\n\n  if (result) result = `${linebreak}${result}${linebreak}`\n\n  return indentStr(`${selector}${space}{${result}`, indent) + indentStr('}', indent)\n}\n","const escapeRegex = /([[\\].#*$><+~=|^:(),\"'`\\s])/g\nconst nativeEscape = typeof CSS !== 'undefined' && CSS.escape\n\nexport default (str) => (nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\\\$1'))\n","import warning from 'tiny-warning'\nimport toCss from '../utils/toCss'\nimport toCssValue from '../utils/toCssValue'\nimport escape from '../utils/escape'\n\nexport class BaseStyleRule {\n  type = 'style'\n\n  isProcessed = false\n\n  constructor(key, style, options) {\n    const {sheet, Renderer} = options\n    this.key = key\n    this.options = options\n    this.style = style\n    if (sheet) this.renderer = sheet.renderer\n    else if (Renderer) this.renderer = new Renderer()\n  }\n\n  /**\n   * Get or set a style property.\n   */\n  prop(name, value, options) {\n    // It's a getter.\n    if (value === undefined) return this.style[name]\n\n    // Don't do anything if the value has not changed.\n    const force = options ? options.force : false\n    if (!force && this.style[name] === value) return this\n\n    let newValue = value\n    if (!options || options.process !== false) {\n      newValue = this.options.jss.plugins.onChangeValue(value, name, this)\n    }\n\n    const isEmpty = newValue == null || newValue === false\n    const isDefined = name in this.style\n\n    // Value is empty and wasn't defined before.\n    if (isEmpty && !isDefined && !force) return this\n\n    // We are going to remove this value.\n    const remove = isEmpty && isDefined\n\n    if (remove) delete this.style[name]\n    else this.style[name] = newValue\n\n    // Renderable is defined if StyleSheet option `link` is true.\n    if (this.renderable && this.renderer) {\n      if (remove) this.renderer.removeProperty(this.renderable, name)\n      else this.renderer.setProperty(this.renderable, name, newValue)\n      return this\n    }\n\n    const {sheet} = this.options\n    if (sheet && sheet.attached) {\n      warning(false, '[JSS] Rule is not linked. Missing sheet option \"link: true\".')\n    }\n    return this\n  }\n}\n\nexport class StyleRule extends BaseStyleRule {\n  constructor(key, style, options) {\n    super(key, style, options)\n    const {selector, scoped, sheet, generateId} = options\n    if (selector) {\n      this.selectorText = selector\n    } else if (scoped !== false) {\n      this.id = generateId(this, sheet)\n      this.selectorText = `.${escape(this.id)}`\n    }\n  }\n\n  /**\n   * Set selector string.\n   * Attention: use this with caution. Most browsers didn't implement\n   * selectorText setter, so this may result in rerendering of entire Style Sheet.\n   */\n  set selector(selector) {\n    if (selector === this.selectorText) return\n\n    this.selectorText = selector\n\n    const {renderer, renderable} = this\n\n    if (!renderable || !renderer) return\n\n    const hasChanged = renderer.setSelector(renderable, selector)\n\n    // If selector setter is not implemented, rerender the rule.\n    if (!hasChanged) {\n      renderer.replaceRule(renderable, this)\n    }\n  }\n\n  /**\n   * Get selector string.\n   */\n  get selector() {\n    return this.selectorText\n  }\n\n  /**\n   * Apply rule to an element inline.\n   */\n  applyTo(renderable) {\n    const {renderer} = this\n    if (renderer) {\n      const json = this.toJSON()\n      for (const prop in json) {\n        renderer.setProperty(renderable, prop, json[prop])\n      }\n    }\n    return this\n  }\n\n  /**\n   * Returns JSON representation of the rule.\n   * Fallbacks are not supported.\n   * Useful for inline styles.\n   */\n  toJSON() {\n    const json = {}\n    for (const prop in this.style) {\n      const value = this.style[prop]\n      if (typeof value !== 'object') json[prop] = value\n      else if (Array.isArray(value)) json[prop] = toCssValue(value)\n    }\n    return json\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n  toString(options) {\n    const {sheet} = this.options\n    const link = sheet ? sheet.options.link : false\n    const opts = link ? {...options, allowEmpty: true} : options\n    return toCss(this.selectorText, this.style, opts)\n  }\n}\n\nexport default {\n  onCreateRule(key, style, options) {\n    if (key[0] === '@' || (options.parent && options.parent.type === 'keyframes')) {\n      return null\n    }\n    return new StyleRule(key, style, options)\n  }\n}\n","import RuleList from '../RuleList'\nimport getWhitespaceSymbols from '../utils/getWhitespaceSymbols'\n\nconst defaultToStringOptions = {\n  indent: 1,\n  children: true\n}\n\nconst atRegExp = /@([\\w-]+)/\n\n/**\n * Conditional rule for @media, @supports\n */\nexport class ConditionalRule {\n  type = 'conditional'\n\n  isProcessed = false\n\n  constructor(key, styles, options) {\n    this.key = key\n    const atMatch = key.match(atRegExp)\n    this.at = atMatch ? atMatch[1] : 'unknown'\n    // Key might contain a unique suffix in case the `name` passed by user was duplicate.\n    this.query = options.name || `@${this.at}`\n    this.options = options\n    this.rules = new RuleList({...options, parent: this})\n\n    for (const name in styles) {\n      this.rules.add(name, styles[name])\n    }\n\n    this.rules.process()\n  }\n\n  /**\n   * Get a rule.\n   */\n  getRule(name) {\n    return this.rules.get(name)\n  }\n\n  /**\n   * Get index of a rule.\n   */\n  indexOf(rule) {\n    return this.rules.indexOf(rule)\n  }\n\n  /**\n   * Create and register rule, run plugins.\n   */\n  addRule(name, style, options) {\n    const rule = this.rules.add(name, style, options)\n    if (!rule) return null\n    this.options.jss.plugins.onProcessRule(rule)\n    return rule\n  }\n\n  /**\n   * Replace rule, run plugins.\n   */\n  replaceRule(name, style, options) {\n    const newRule = this.rules.replace(name, style, options)\n    if (newRule) this.options.jss.plugins.onProcessRule(newRule)\n    return newRule\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n  toString(options = defaultToStringOptions) {\n    const {linebreak} = getWhitespaceSymbols(options)\n    if (options.indent == null) options.indent = defaultToStringOptions.indent\n    if (options.children == null) options.children = defaultToStringOptions.children\n    if (options.children === false) {\n      return `${this.query} {}`\n    }\n    const children = this.rules.toString(options)\n    return children ? `${this.query} {${linebreak}${children}${linebreak}}` : ''\n  }\n}\n\nconst keyRegExp = /@container|@media|@supports\\s+/\n\nexport default {\n  onCreateRule(key, styles, options) {\n    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null\n  }\n}\n","import warning from 'tiny-warning'\nimport RuleList from '../RuleList'\nimport escape from '../utils/escape'\nimport getWhitespaceSymbols from '../utils/getWhitespaceSymbols'\n\nconst defaultToStringOptions = {\n  indent: 1,\n  children: true\n}\n\nconst nameRegExp = /@keyframes\\s+([\\w-]+)/\n\n/**\n * Rule for @keyframes\n */\nexport class KeyframesRule {\n  type = 'keyframes'\n\n  at = '@keyframes'\n\n  isProcessed = false\n\n  constructor(key, frames, options) {\n    const nameMatch = key.match(nameRegExp)\n    if (nameMatch && nameMatch[1]) {\n      this.name = nameMatch[1]\n    } else {\n      this.name = 'noname'\n      warning(false, `[JSS] Bad keyframes name ${key}`)\n    }\n    this.key = `${this.type}-${this.name}`\n    this.options = options\n    const {scoped, sheet, generateId} = options\n    this.id = scoped === false ? this.name : escape(generateId(this, sheet))\n    this.rules = new RuleList({...options, parent: this})\n\n    for (const name in frames) {\n      this.rules.add(name, frames[name], {\n        ...options,\n        parent: this\n      })\n    }\n\n    this.rules.process()\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n  toString(options = defaultToStringOptions) {\n    const {linebreak} = getWhitespaceSymbols(options)\n    if (options.indent == null) options.indent = defaultToStringOptions.indent\n    if (options.children == null) options.children = defaultToStringOptions.children\n    if (options.children === false) {\n      return `${this.at} ${this.id} {}`\n    }\n    let children = this.rules.toString(options)\n    if (children) children = `${linebreak}${children}${linebreak}`\n    return `${this.at} ${this.id} {${children}}`\n  }\n}\n\nconst keyRegExp = /@keyframes\\s+/\n\nconst refRegExp = /\\$([\\w-]+)/g\n\nconst findReferencedKeyframe = (val, keyframes) => {\n  if (typeof val === 'string') {\n    return val.replace(refRegExp, (match, name) => {\n      if (name in keyframes) {\n        return keyframes[name]\n      }\n\n      warning(false, `[JSS] Referenced keyframes rule \"${name}\" is not defined.`)\n\n      return match\n    })\n  }\n\n  return val\n}\n\n/**\n * Replace the reference for a animation name.\n */\nconst replaceRef = (style, prop, keyframes) => {\n  const value = style[prop]\n  const refKeyframe = findReferencedKeyframe(value, keyframes)\n\n  if (refKeyframe !== value) {\n    style[prop] = refKeyframe\n  }\n}\n\nexport default {\n  onCreateRule(key, frames, options) {\n    return typeof key === 'string' && keyRegExp.test(key)\n      ? new KeyframesRule(key, frames, options)\n      : null\n  },\n\n  // Animation name ref replacer.\n  onProcessStyle: (style, rule, sheet) => {\n    if (rule.type !== 'style' || !sheet) return style\n\n    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes)\n    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes)\n    return style\n  },\n\n  onChangeValue(val, prop, rule) {\n    const {sheet} = rule.options\n\n    if (!sheet) {\n      return val\n    }\n\n    switch (prop) {\n      case 'animation':\n        return findReferencedKeyframe(val, sheet.keyframes)\n      case 'animation-name':\n        return findReferencedKeyframe(val, sheet.keyframes)\n      default:\n        return val\n    }\n  }\n}\n","import toCss from '../utils/toCss'\nimport {BaseStyleRule} from './styleRule'\n\nexport class KeyframeRule extends BaseStyleRule {\n  /**\n   * Generates a CSS string.\n   */\n  toString(options) {\n    const {sheet} = this.options\n    const link = sheet ? sheet.options.link : false\n    const opts = link ? {...options, allowEmpty: true} : options\n    return toCss(this.key, this.style, opts)\n  }\n}\n\nexport default {\n  onCreateRule(key, style, options) {\n    if (options.parent && options.parent.type === 'keyframes') {\n      return new KeyframeRule(key, style, options)\n    }\n    return null\n  }\n}\n","import toCss from '../utils/toCss'\nimport getWhitespaceSymbols from '../utils/getWhitespaceSymbols'\n\nexport class FontFaceRule {\n  type = 'font-face'\n\n  at = '@font-face'\n\n  isProcessed = false\n\n  constructor(key, style, options) {\n    this.key = key\n    this.style = style\n    this.options = options\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n  toString(options) {\n    const {linebreak} = getWhitespaceSymbols(options)\n    if (Array.isArray(this.style)) {\n      let str = ''\n      for (let index = 0; index < this.style.length; index++) {\n        str += toCss(this.at, this.style[index])\n        if (this.style[index + 1]) str += linebreak\n      }\n      return str\n    }\n\n    return toCss(this.at, this.style, options)\n  }\n}\n\nconst keyRegExp = /@font-face/\n\nexport default {\n  onCreateRule(key, style, options) {\n    return keyRegExp.test(key) ? new FontFaceRule(key, style, options) : null\n  }\n}\n","import toCss from '../utils/toCss'\n\nexport class ViewportRule {\n  type = 'viewport'\n\n  at = '@viewport'\n\n  isProcessed = false\n\n  constructor(key, style, options) {\n    this.key = key\n    this.style = style\n    this.options = options\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n  toString(options) {\n    return toCss(this.key, this.style, options)\n  }\n}\n\nexport default {\n  onCreateRule(key, style, options) {\n    return key === '@viewport' || key === '@-ms-viewport'\n      ? new ViewportRule(key, style, options)\n      : null\n  }\n}\n","export class SimpleRule {\n  type = 'simple'\n\n  isProcessed = false\n\n  constructor(key, value, options) {\n    this.key = key\n    this.value = value\n    this.options = options\n  }\n\n  /**\n   * Generates a CSS string.\n   */\n  // eslint-disable-next-line no-unused-vars\n  toString(options) {\n    if (Array.isArray(this.value)) {\n      let str = ''\n      for (let index = 0; index < this.value.length; index++) {\n        str += `${this.key} ${this.value[index]};`\n        if (this.value[index + 1]) str += '\\n'\n      }\n      return str\n    }\n\n    return `${this.key} ${this.value};`\n  }\n}\n\nconst keysMap = {\n  '@charset': true,\n  '@import': true,\n  '@namespace': true\n}\n\nexport default {\n  onCreateRule(key, value, options) {\n    return key in keysMap ? new SimpleRule(key, value, options) : null\n  }\n}\n","import pluginStyleRule, {StyleRule} from './styleRule'\nimport pluginConditionalRule, {ConditionalRule} from './conditionalRule'\nimport pluginKeyframesRule, {KeyframesRule} from './keyframesRule'\nimport pluginKeyframeRule, {KeyframeRule} from './keyframeRule'\nimport pluginFontFaceRule, {FontFaceRule} from './fontFaceRule'\nimport pluginViewportRule, {ViewportRule} from './viewportRule'\nimport pluginSimpleRule, {SimpleRule} from './simpleRule'\n\nexport const plugins = [\n  pluginStyleRule,\n  pluginConditionalRule,\n  pluginKeyframesRule,\n  pluginKeyframeRule,\n  pluginFontFaceRule,\n  pluginViewportRule,\n  pluginSimpleRule\n]\n\nexport {\n  StyleRule,\n  ConditionalRule,\n  KeyframesRule,\n  KeyframeRule,\n  FontFaceRule,\n  ViewportRule,\n  SimpleRule\n}\n","import createRule from './utils/createRule'\nimport {StyleRule, KeyframesRule} from './plugins/index'\nimport escape from './utils/escape'\nimport getWhitespaceSymbols from './utils/getWhitespaceSymbols'\n\nconst defaultUpdateOptions = {\n  process: true\n}\n\nconst forceUpdateOptions = {\n  force: true,\n  process: true\n}\n\n/**\n * Contains rules objects and allows adding/removing etc.\n * Is used for e.g. by `StyleSheet` or `ConditionalRule`.\n */\nexport default class RuleList {\n  // Rules registry for access by .get() method.\n  // It contains the same rule registered by name and by selector.\n  map = {}\n\n  // Original styles object.\n  raw = {}\n\n  // Used to ensure correct rules order.\n  index = []\n\n  counter = 0\n\n  constructor(options) {\n    this.options = options\n    this.classes = options.classes\n    this.keyframes = options.keyframes\n  }\n\n  /**\n   * Create and register rule.\n   *\n   * Will not render after Style Sheet was rendered the first time.\n   */\n  add(name, decl, ruleOptions) {\n    const {parent, sheet, jss, Renderer, generateId, scoped} = this.options\n    const options = {\n      classes: this.classes,\n      parent,\n      sheet,\n      jss,\n      Renderer,\n      generateId,\n      scoped,\n      name,\n      keyframes: this.keyframes,\n      selector: undefined,\n      ...ruleOptions\n    }\n\n    // When user uses .createStyleSheet(), duplicate names are not possible, but\n    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens\n    // we need to make the key unique within this RuleList instance scope.\n    let key = name\n    if (name in this.raw) {\n      key = `${name}-d${this.counter++}`\n    }\n\n    // We need to save the original decl before creating the rule\n    // because cache plugin needs to use it as a key to return a cached rule.\n    this.raw[key] = decl\n\n    if (key in this.classes) {\n      // E.g. rules inside of @media container\n      options.selector = `.${escape(this.classes[key])}`\n    }\n\n    const rule = createRule(key, decl, options)\n\n    if (!rule) return null\n\n    this.register(rule)\n\n    const index = options.index === undefined ? this.index.length : options.index\n    this.index.splice(index, 0, rule)\n\n    return rule\n  }\n\n  /**\n   * Replace rule.\n   * Create a new rule and remove old one instead of overwriting\n   * because we want to invoke onCreateRule hook to make plugins work.\n   */\n  replace(name, decl, ruleOptions) {\n    const oldRule = this.get(name)\n    const oldIndex = this.index.indexOf(oldRule)\n    if (oldRule) {\n      this.remove(oldRule)\n    }\n    let options = ruleOptions\n    if (oldIndex !== -1) options = {...ruleOptions, index: oldIndex}\n    return this.add(name, decl, options)\n  }\n\n  /**\n   * Get a rule by name or selector.\n   */\n  get(nameOrSelector) {\n    return this.map[nameOrSelector]\n  }\n\n  /**\n   * Delete a rule.\n   */\n  remove(rule) {\n    this.unregister(rule)\n    delete this.raw[rule.key]\n    this.index.splice(this.index.indexOf(rule), 1)\n  }\n\n  /**\n   * Get index of a rule.\n   */\n  indexOf(rule) {\n    return this.index.indexOf(rule)\n  }\n\n  /**\n   * Run `onProcessRule()` plugins on every rule.\n   */\n  process() {\n    const {plugins} = this.options.jss\n    // We need to clone array because if we modify the index somewhere else during a loop\n    // we end up with very hard-to-track-down side effects.\n    this.index.slice(0).forEach(plugins.onProcessRule, plugins)\n  }\n\n  /**\n   * Register a rule in `.map`, `.classes` and `.keyframes` maps.\n   */\n  register(rule) {\n    this.map[rule.key] = rule\n    if (rule instanceof StyleRule) {\n      this.map[rule.selector] = rule\n      if (rule.id) this.classes[rule.key] = rule.id\n    } else if (rule instanceof KeyframesRule && this.keyframes) {\n      this.keyframes[rule.name] = rule.id\n    }\n  }\n\n  /**\n   * Unregister a rule.\n   */\n  unregister(rule) {\n    delete this.map[rule.key]\n    if (rule instanceof StyleRule) {\n      delete this.map[rule.selector]\n      delete this.classes[rule.key]\n    } else if (rule instanceof KeyframesRule) {\n      delete this.keyframes[rule.name]\n    }\n  }\n\n  /**\n   * Update the function values with a new data.\n   */\n  update(...args) {\n    let name\n    let data\n    let options\n\n    if (typeof args[0] === 'string') {\n      name = args[0]\n      data = args[1]\n      options = args[2]\n    } else {\n      data = args[0]\n      options = args[1]\n      name = null\n    }\n\n    if (name) {\n      this.updateOne(this.get(name), data, options)\n    } else {\n      for (let index = 0; index < this.index.length; index++) {\n        this.updateOne(this.index[index], data, options)\n      }\n    }\n  }\n\n  /**\n   * Execute plugins, update rule props.\n   */\n  updateOne(rule, data, options = defaultUpdateOptions) {\n    const {\n      jss: {plugins},\n      sheet\n    } = this.options\n\n    // It is a rules container like for e.g. ConditionalRule.\n    if (rule.rules instanceof RuleList) {\n      rule.rules.update(data, options)\n      return\n    }\n\n    const {style} = rule\n\n    plugins.onUpdate(data, rule, sheet, options)\n\n    // We rely on a new `style` ref in case it was mutated during onUpdate hook.\n    if (options.process && style && style !== rule.style) {\n      // We need to run the plugins in case new `style` relies on syntax plugins.\n      plugins.onProcessStyle(rule.style, rule, sheet)\n\n      // Update and add props.\n      for (const prop in rule.style) {\n        const nextValue = rule.style[prop]\n        const prevValue = style[prop]\n        // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n        if (nextValue !== prevValue) {\n          rule.prop(prop, nextValue, forceUpdateOptions)\n        }\n      }\n\n      // Remove props.\n      for (const prop in style) {\n        const nextValue = rule.style[prop]\n        const prevValue = style[prop]\n        // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n        if (nextValue == null && nextValue !== prevValue) {\n          rule.prop(prop, null, forceUpdateOptions)\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert rules to a CSS string.\n   */\n  toString(options) {\n    let str = ''\n    const {sheet} = this.options\n    const link = sheet ? sheet.options.link : false\n    const {linebreak} = getWhitespaceSymbols(options)\n\n    for (let index = 0; index < this.index.length; index++) {\n      const rule = this.index[index]\n      const css = rule.toString(options)\n\n      // No need to render an empty rule.\n      if (!css && !link) continue\n\n      if (str) str += linebreak\n      str += css\n    }\n\n    return str\n  }\n}\n","import RuleList from './RuleList'\n\nexport default class StyleSheet {\n  constructor(styles, options) {\n    this.attached = false\n    this.deployed = false\n    this.classes = {}\n    this.keyframes = {}\n    this.options = {\n      ...options,\n      sheet: this,\n      parent: this,\n      classes: this.classes,\n      keyframes: this.keyframes\n    }\n    if (options.Renderer) {\n      this.renderer = new options.Renderer(this)\n    }\n    this.rules = new RuleList(this.options)\n\n    for (const name in styles) {\n      this.rules.add(name, styles[name])\n    }\n\n    this.rules.process()\n  }\n\n  /**\n   * Attach renderable to the render tree.\n   */\n  attach() {\n    if (this.attached) return this\n    if (this.renderer) this.renderer.attach()\n    this.attached = true\n    // Order is important, because we can't use insertRule API if style element is not attached.\n    if (!this.deployed) this.deploy()\n    return this\n  }\n\n  /**\n   * Remove renderable from render tree.\n   */\n  detach() {\n    if (!this.attached) return this\n    if (this.renderer) this.renderer.detach()\n    this.attached = false\n    return this\n  }\n\n  /**\n   * Add a rule to the current stylesheet.\n   * Will insert a rule also after the stylesheet has been rendered first time.\n   */\n  addRule(name, decl, options) {\n    const {queue} = this\n\n    // Plugins can create rules.\n    // In order to preserve the right order, we need to queue all `.addRule` calls,\n    // which happen after the first `rules.add()` call.\n    if (this.attached && !queue) this.queue = []\n\n    const rule = this.rules.add(name, decl, options)\n\n    if (!rule) return null\n\n    this.options.jss.plugins.onProcessRule(rule)\n\n    if (this.attached) {\n      if (!this.deployed) return rule\n      // Don't insert rule directly if there is no stringified version yet.\n      // It will be inserted all together when .attach is called.\n      if (queue) queue.push(rule)\n      else {\n        this.insertRule(rule)\n        if (this.queue) {\n          this.queue.forEach(this.insertRule, this)\n          this.queue = undefined\n        }\n      }\n      return rule\n    }\n\n    // We can't add rules to a detached style node.\n    // We will redeploy the sheet once user will attach it.\n    this.deployed = false\n\n    return rule\n  }\n\n  /**\n   * Replace a rule in the current stylesheet.\n   */\n  replaceRule(nameOrSelector, decl, options) {\n    const oldRule = this.rules.get(nameOrSelector)\n    if (!oldRule) return this.addRule(nameOrSelector, decl, options)\n\n    const newRule = this.rules.replace(nameOrSelector, decl, options)\n\n    if (newRule) {\n      this.options.jss.plugins.onProcessRule(newRule)\n    }\n\n    if (this.attached) {\n      if (!this.deployed) return newRule\n      // Don't replace / delete rule directly if there is no stringified version yet.\n      // It will be inserted all together when .attach is called.\n      if (this.renderer) {\n        if (!newRule) {\n          this.renderer.deleteRule(oldRule)\n        } else if (oldRule.renderable) {\n          this.renderer.replaceRule(oldRule.renderable, newRule)\n        }\n      }\n      return newRule\n    }\n\n    // We can't replace rules to a detached style node.\n    // We will redeploy the sheet once user will attach it.\n    this.deployed = false\n\n    return newRule\n  }\n\n  /**\n   * Insert rule into the StyleSheet\n   */\n  insertRule(rule) {\n    if (this.renderer) {\n      this.renderer.insertRule(rule)\n    }\n  }\n\n  /**\n   * Create and add rules.\n   * Will render also after Style Sheet was rendered the first time.\n   */\n  addRules(styles, options) {\n    const added = []\n    for (const name in styles) {\n      const rule = this.addRule(name, styles[name], options)\n      if (rule) added.push(rule)\n    }\n    return added\n  }\n\n  /**\n   * Get a rule by name or selector.\n   */\n  getRule(nameOrSelector) {\n    return this.rules.get(nameOrSelector)\n  }\n\n  /**\n   * Delete a rule by name.\n   * Returns `true`: if rule has been deleted from the DOM.\n   */\n  deleteRule(name) {\n    const rule = typeof name === 'object' ? name : this.rules.get(name)\n\n    if (\n      !rule ||\n      // Style sheet was created without link: true and attached, in this case we\n      // won't be able to remove the CSS rule from the DOM.\n      (this.attached && !rule.renderable)\n    ) {\n      return false\n    }\n\n    this.rules.remove(rule)\n\n    if (this.attached && rule.renderable && this.renderer) {\n      return this.renderer.deleteRule(rule.renderable)\n    }\n\n    return true\n  }\n\n  /**\n   * Get index of a rule.\n   */\n  indexOf(rule) {\n    return this.rules.indexOf(rule)\n  }\n\n  /**\n   * Deploy pure CSS string to a renderable.\n   */\n  deploy() {\n    if (this.renderer) this.renderer.deploy()\n    this.deployed = true\n    return this\n  }\n\n  /**\n   * Update the function values with a new data.\n   */\n  update(...args) {\n    this.rules.update(...args)\n    return this\n  }\n\n  /**\n   * Updates a single rule.\n   */\n  updateOne(rule, data, options) {\n    this.rules.updateOne(rule, data, options)\n    return this\n  }\n\n  /**\n   * Convert rules to a CSS string.\n   */\n  toString(options) {\n    return this.rules.toString(options)\n  }\n}\n","import warning from 'tiny-warning'\n\nexport default class PluginsRegistry {\n  plugins = {\n    internal: [],\n    external: []\n  }\n\n  registry = {}\n\n  /**\n   * Call `onCreateRule` hooks and return an object if returned by a hook.\n   */\n  onCreateRule(name, decl, options) {\n    for (let i = 0; i < this.registry.onCreateRule.length; i++) {\n      const rule = this.registry.onCreateRule[i](name, decl, options)\n      if (rule) return rule\n    }\n\n    return null\n  }\n\n  /**\n   * Call `onProcessRule` hooks.\n   */\n  onProcessRule(rule) {\n    if (rule.isProcessed) return\n    const {sheet} = rule.options\n    for (let i = 0; i < this.registry.onProcessRule.length; i++) {\n      this.registry.onProcessRule[i](rule, sheet)\n    }\n\n    if (rule.style) this.onProcessStyle(rule.style, rule, sheet)\n\n    rule.isProcessed = true\n  }\n\n  /**\n   * Call `onProcessStyle` hooks.\n   */\n  onProcessStyle(style, rule, sheet) {\n    for (let i = 0; i < this.registry.onProcessStyle.length; i++) {\n      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet)\n    }\n  }\n\n  /**\n   * Call `onProcessSheet` hooks.\n   */\n  onProcessSheet(sheet) {\n    for (let i = 0; i < this.registry.onProcessSheet.length; i++) {\n      this.registry.onProcessSheet[i](sheet)\n    }\n  }\n\n  /**\n   * Call `onUpdate` hooks.\n   */\n  onUpdate(data, rule, sheet, options) {\n    for (let i = 0; i < this.registry.onUpdate.length; i++) {\n      this.registry.onUpdate[i](data, rule, sheet, options)\n    }\n  }\n\n  /**\n   * Call `onChangeValue` hooks.\n   */\n  onChangeValue(value, prop, rule) {\n    let processedValue = value\n    for (let i = 0; i < this.registry.onChangeValue.length; i++) {\n      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule)\n    }\n    return processedValue\n  }\n\n  /**\n   * Register a plugin.\n   */\n  use(newPlugin, options = {queue: 'external'}) {\n    const plugins = this.plugins[options.queue]\n\n    // Avoids applying same plugin twice, at least based on ref.\n    if (plugins.indexOf(newPlugin) !== -1) {\n      return\n    }\n\n    plugins.push(newPlugin)\n\n    this.registry = [...this.plugins.external, ...this.plugins.internal].reduce(\n      (registry, plugin) => {\n        for (const name in plugin) {\n          if (name in registry) {\n            registry[name].push(plugin[name])\n          } else {\n            warning(false, `[JSS] Unknown hook \"${name}\".`)\n          }\n        }\n        return registry\n      },\n      {\n        onCreateRule: [],\n        onProcessRule: [],\n        onProcessStyle: [],\n        onProcessSheet: [],\n        onChangeValue: [],\n        onUpdate: []\n      }\n    )\n  }\n}\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import getWhitespaceSymbols from './utils/getWhitespaceSymbols'\n/**\n * Sheets registry to access all instances in one place.\n */\nexport default class SheetsRegistry {\n  registry = []\n\n  /**\n   * Current highest index number.\n   */\n  get index() {\n    return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index\n  }\n\n  /**\n   * Register a Style Sheet.\n   */\n  add(sheet) {\n    const {registry} = this\n    const {index} = sheet.options\n\n    if (registry.indexOf(sheet) !== -1) return\n\n    if (registry.length === 0 || index >= this.index) {\n      registry.push(sheet)\n      return\n    }\n\n    // Find a position.\n    for (let i = 0; i < registry.length; i++) {\n      if (registry[i].options.index > index) {\n        registry.splice(i, 0, sheet)\n        return\n      }\n    }\n  }\n\n  /**\n   * Reset the registry.\n   */\n  reset() {\n    this.registry = []\n  }\n\n  /**\n   * Remove a Style Sheet.\n   */\n  remove(sheet) {\n    const index = this.registry.indexOf(sheet)\n    this.registry.splice(index, 1)\n  }\n\n  /**\n   * Convert all attached sheets to a CSS string.\n   */\n  toString({attached, ...options} = {}) {\n    const {linebreak} = getWhitespaceSymbols(options)\n    let css = ''\n    for (let i = 0; i < this.registry.length; i++) {\n      const sheet = this.registry[i]\n      if (attached != null && sheet.attached !== attached) {\n        continue\n      }\n      if (css) css += linebreak\n      css += sheet.toString(options)\n    }\n    return css\n  }\n}\n","import SheetsRegistry from './SheetsRegistry'\n\n/**\n * This is a global sheets registry. Only DomRenderer will add sheets to it.\n * On the server one should use an own SheetsRegistry instance and add the\n * sheets to it, because you need to make sure to create a new registry for\n * each request in order to not leak sheets across requests.\n */\nexport default new SheetsRegistry()\n","/* eslint-disable */\n\n/**\n * Now that `glob